<?php namespace System\Core{ use System\Exception\CoraxException; use System\Corax; use System\Util\SEK; defined('BASE_PATH') or die('No Permission!'); class Configer{ const CONFIGTYPE_PHP = '.php'; const CONFIGTYPE_INI = '.ini'; private static $convention = [ 'CONFIG_LIST' => [ 'custom','database','guide','hook','log','modules','route','security','template','cache' ], 'REFRESH_INTERVAL' => 3600, 'CACHE_DRIVER_TYPE' => Cache::CACHEMODE_FILE, ]; private static $config_cache = null; public static function init($forceRefresh=false){ Corax::status('config_init_begin'); SEK::merge(self::$convention,self::read(CONFIG_PATH.'configer.php')); if($forceRefresh or (null === (self::$config_cache = Cache::get('configure',null,self::$convention['CACHE_DRIVER_TYPE']))) ){ foreach(self::$convention['CONFIG_LIST'] as $dir=>$item){ if(!is_numeric($dir)){ foreach($item as $subitem){ self::$config_cache["{$dir}.{$subitem}"] = self::read(CONFIG_PATH."{$dir}/{$subitem}.php"); } }else{ self::$config_cache[$item] = self::read(CONFIG_PATH."{$item}.php"); } } Cache::set('configure',self::$config_cache,self::$convention['REFRESH_INTERVAL'],self::$convention['CACHE_DRIVER_TYPE']); Corax::status('config_init_create_cache_done'); } Corax::status('config_init_end'); } public static function load($confnm='custom'){ null === self::$config_cache and self::init(); $confnm = strtolower($confnm); if(!isset(self::$config_cache[$confnm])){ throw new CoraxException("Configure item '{$confnm}' not exist!"); } return self::$config_cache[$confnm]; } public static function get($confnm = null,$rplvalue=null){ null === self::$config_cache and self::init(); $configes = null; if(null === $confnm){ return self::$config_cache; } if(false !== strpos($confnm,'.')){ $configes = explode('.',$confnm); $confnm = array_shift($configes); } $rtn = self::load($confnm); if($configes){ foreach($configes as $val){ $val = strtoupper($val); if(isset($rtn[$val])){ $rtn = $rtn[$val]; }else{ return $rplvalue; } } } return $rtn; } public static function set($confnm,$value){ null === self::$config_cache and self::init(); $configes = null; if(false !== strpos($confnm,'.')){ $configes = explode('.',$confnm); $confnm = array_shift($configes); } $confnm = strtolower($confnm); if(!isset(self::$config_cache[$confnm])){ throw new CoraxException($confnm); } $confvars = &self::$config_cache[$confnm]; if($configes){ foreach($configes as $val){ if(!isset($confvars[$val])){ $confvars[$val] = []; } $confvars = &$confvars[$val]; } $confvars = $value; } } public static function read($path,$type=self::CONFIGTYPE_PHP){ static $_conf = array(); if(!isset($_conf[$path])){ switch($type){ case self::CONFIGTYPE_PHP: default: $_conf[$path] = include $path; } } return $_conf[$path]; } public static function write($path,array $config,$type=self::CONFIGTYPE_PHP){ switch($type){ case self::CONFIGTYPE_PHP: default: $filename = pathinfo($path,PATHINFO_FILENAME); $confname = substr($filename,0,strpos($filename,'.')); self::$config_cache[$confname] = $config; return Storage::write($path,'<?php return '.var_export($config,true).';'); } } }}namespace System\Core{ use System\Corax; use System\Exception\CoraxException; use System\Util\SEK; defined('BASE_PATH') or die('No Permission!'); class Dispatcher{ protected static $convention = []; protected static $hasInited = false; public static function init(){ SEK::merge(self::$convention,Configer::load('dispatcher'),true); static::$hasInited = true; } public static function execute($modules,$ctrler,$action,array $parameters=array()){ Corax::status('execute_begin'); self::$hasInited or self::init(); if(!isset($modules,$ctrler,$action)){ throw new CoraxException($modules,$ctrler,$action,$parameters); } if(is_array($modules)){ $temp = ''; foreach($modules as $val){ if(self::checkAllValid($val)){ $temp .= "$val\\"; } } $modules = trim($temp,'\\'); }else{ if(!self::checkAllValid($modules)){ throw new CoraxException($modules); } } Corax::status('execute_instance_build_init_begin'); $className = "Application\\{$modules}\\Controller\\{$ctrler}Controller"; if(isset($_POST['_PARAMS_'])){ parse_str($_POST['_PARAMS_'],$temp); unset($_POST['_PARAMS_']); $_POST = array_merge($_POST,$temp); } if(isset($_GET['_PARAMS_'])){ parse_str($_GET['_PARAMS_'],$temp); unset($_GET['_PARAMS_']); $_GET = array_merge($_GET,$temp); } $_REQUEST = array_merge($_GET,$_POST); Corax::status('execute_instance_build_begin'); $classInstance = new $className(); Corax::status('execute_instance_build_end'); $targetMethod = new \ReflectionMethod($classInstance, $action); if ($targetMethod->isPublic() && !$targetMethod->isStatic()) { $class = new \ReflectionClass($classInstance); if ($class->hasMethod('_before_' . $action)) { $beforeMethod = $class->getMethod('_before_' . $action); if ($beforeMethod->isPublic()) { $beforeMethod->invoke($classInstance, $parameters); } } if ($targetMethod->getNumberOfParameters()) { $vars = array(); switch(strtoupper($_SERVER['REQUEST_METHOD'])){ case 'POST': $vars = array_merge($_GET,$_POST); break; case 'PUT': parse_str(file_get_contents('php://input'), $vars); break; default: $vars = $_GET; } $methodParams = $targetMethod->getParameters(); $args = array(); foreach ($methodParams as $param) { $parameterName = $param->getName(); if(isset($vars[$parameterName])){ $args[] = $vars[$parameterName]; }elseif($param->isDefaultValueAvailable()){ $args[] = $param->getDefaultValue(); }else{ throw new \Exception("Method do not get valid  parameter with name of $parameterName !"); } } $targetMethod->invokeArgs($classInstance, $args); } else { $targetMethod->invoke($classInstance); } if ($class->hasMethod('_after_' . $action)) { $after = $class->getMethod('_after_' . $action); if ($after->isPublic()) { $after->invoke($classInstance); } } } else { throw new CoraxException($className, $action); } Corax::status('execute_method_called_end'); } private static function checkAllValid(){ $args = func_get_args(); foreach($args as $val){ if(is_array($val)){ foreach($val as $k=>$v){ if(!self::checkAllValid($v)){ return false; } } }else{ if(!preg_match('/^[A-Za-z](\/|\w)*$/',$val)){ return false; } } } return true; } }}namespace System\Core{ use System\Corax; use System\Util\SEK; use System\Util\UDK; defined('BASE_PATH') or die('No Permission!'); class Controller{ protected $_tVars = array(); protected $_view = null; protected $context = [ 'm' => null, 'c' => null, 't' => null, ]; protected $module_path = null; protected static $template_engine = null; public function __construct($context = null){ $matches = null; if(preg_match('/^Application\\\(.*)\\\Controller\\\(.*)Controller$/',get_called_class(),$matches)){ $this->context['m'] = str_replace('\\','/',$matches[1]); $this->context['c'] = $matches[2]; }else{ throw new \Exception('Class "'.get_called_class().'" can not fetch modules and controller!'); } null === $context or $this->context = array_merge($this->context,$context); $this->module_path = BASE_PATH.'Application/'.$this->context['m'].'/'; } protected function ajax($data,$type='JSON',$json_option=0) { switch (strtoupper($type)){ case 'JSON' : header('Content-Type:application/json; charset=utf-8'); exit(json_encode($data,$json_option)); case 'XML' : header('Content-Type:text/xml; charset=utf-8'); exit(SEK::encodeHtml($data)); default: throw new \Exception('Unknown rReturn content type'); } } protected function ajaxSuccess($message){ $this->ajax(array( 'type' => 'success', 'message' => $message )); } protected function ajaxFaiure($message){ $this->ajax(array( 'type' => 'failure', 'message' => $message )); } public function success($message,$waittime=1,$title='success'){ self::jump($message,$title,true,1,$waittime); } public function error($message,$waittime=3,$title='error'){ self::jump($message,$title,false,1,$waittime); } public function redirect($compo,array $params=array(),$time=0,$message=''){ SEK::redirect(SEK::url($compo,$params),$time,$message); } protected static function jump($message,$title='跳转',$status=true,$jumpto=-1,$wait=1) { header( 'Expires: Mon, 26 Jul 1997 05:00:00 GMT' ); header( 'Last-Modified: ' . gmdate( 'D, d M Y H:i:s' ) . ' GMT' ); header( 'Cache-Control: no-store, no-cache, must-revalidate' ); header( 'Cache-Control: post-check=0, pre-check=0', false ); header( 'Pragma: no-cache' ); $vars = array(); $vars['wait'] = $wait; $vars['title'] = $title; $vars['message'] = $message; $vars['status'] = $status?1:0; switch($jumpto){ case 1: $vars['jumpurl'] = 'javascript:history.back(-1);'; break; case -1: $vars['jumpurl'] = 'javascript:history.back(-1);'; break; case 0: default: $vars['jumpurl'] = 'javascript:window.close();'; } Corax::loadTemplate('jump',$vars); } public function theme($tname){ $this->context['t'] = $tname; } public function assign($tpl_var,$value=null,$nocache=false){ if (is_array($tpl_var)) { foreach ($tpl_var as $_key => $_val) { if ($_key != '') { $this->_tVars[$_key] = array($_val,$nocache); } } } else { if ($tpl_var != '') { $this->_tVars[$tpl_var] = array($value,$nocache); } } } public function display($template = null, $cache_id = null, $compile_id = null, $parent = null){ if(!$template){ $trace = debug_backtrace(DEBUG_BACKTRACE_PROVIDE_OBJECT,2); $this->context['a'] = $trace[1]['function']; } Corax::status('display_c_begin'); if(null === $this->_view) $this->initView(); foreach($this->_tVars as $key => $value){ $this->_view->assign($key,$value[0],$value[1]); } Corax::status('display_cc_begin'); $this->_view->display($template,$cache_id,$compile_id,$parent); } protected function initView(){ $this->_view = new View($this->context); self::$template_engine = &View::$tpl_engine; } }}namespace System\Core{ use System\Corax; use System\Exception\CoraxException; defined('BASE_PATH') or die('No Permission!'); class Log{ const LOGTYPE_FILE = 'File'; const LOGTYPE_DATABASE = 'Database'; const LOGTYPE_MEMCACHE = 'Memcache'; const LOGTYPE_SAE = 'Sae'; const LOG_LEVEL_DEBUG = 'Debug'; const LOG_LEVEL_TRACE = 'Trace'; const LOGRATE_HOUR = 0; const LOGRATE_DAY = 1; private static $_driver = null; private static $log_rate = null; public static function init($type = self::LOGTYPE_FILE,$rate = self::LOGRATE_DAY){ Corax::status('log_init_begin'); self::$log_rate = $rate; if(null === self::$_driver){ $clsnm = "System\\Core\\Log\\$type"; if(!class_exists($clsnm)){ throw new CoraxException("Log driver '{$clsnm}' not exist!"); } self::$_driver = new $clsnm(); } Corax::status('log_init_end'); } public static function write($content,$level=self::LOG_LEVEL_DEBUG){ self::$_driver or self::init(); return self::$_driver->write($content,$level); } public static function read($ymd, $level=self::LOG_LEVEL_DEBUG){ self::$_driver or self::init(); return self::$_driver->read($ymd,$level); } public static function debug(){ self::$_driver or self::init();$content = ''; if(DEBUG_MODE_ON){ $params = func_get_args(); foreach($params as $val){ $content .= var_export($val,true); } self::$_driver->write($content,self::LOG_LEVEL_DEBUG); } return $content; } public static function trace(){ self::$_driver or self::init(); $content = ''; if(DEBUG_MODE_ON){ $params = func_get_args(); foreach($params as $val){ $content .= '█TRACE█'.var_export($val,true); } self::$_driver->write($content,self::LOG_LEVEL_TRACE); } return $content; } }}namespace System\Core{ use System\Corax; defined('BASE_PATH') or die('No Permission!'); class Storage { const FILEINFO_LAST_ACCESS_TIME = 'fileatime'; const FILEINFO_LAST_MODIFIED_TIME = 'filemtime'; const FILEINFO_PERMISSION = 'fileperms'; const FILEINFO_SIZE = 'filesize'; const FILEINFO_TYPE = 'filetype'; const STORAGEMODE_FILE = 'File'; const STORAGEMODE_SAE = 'Sae'; const STORAGEMODE_KVDB = 'Kvdb'; const STORAGEMODE_MEMCACHE = 'Memcache'; private static $driver = null; private static $hasInited = false; private function __construct(){} public static function init($mode=null){ Corax::status('storage_init_begin'); if(null === $mode and RUNTIME_ENVIRONMENT === self::STORAGEMODE_SAE){ $mode = self::STORAGEMODE_SAE; }else{ $mode = self::STORAGEMODE_FILE; } $driverName = "System\\Core\\Storage\\{$mode}"; self::$driver = new $driverName(); self::$hasInited = true; Corax::status('storage_init_done'); } public static function read($filepath,$file_encoding='UTF-8',$output_encode='UTF-8'){ self::$hasInited or self::init(); return self::$driver->read($filepath,$file_encoding,$output_encode); } public static function write($filepath,$content,$write_encode='UTF-8'){ self::$hasInited or self::init(); return self::$driver->write($filepath,$content,$write_encode); } public static function append($filename,$content,$write_encode='UTF-8'){ self::$hasInited or self::init(); return self::$driver->append($filename,$content,$write_encode); } public static function has($filename){ self::$hasInited or self::init(); return self::$driver->has($filename); } public static function unlink($filename){ self::$hasInited or self::init(); return self::$driver->unlink($filename); } public static function removeFolder($dir,$recursion=false) { self::$hasInited or self::init(); return self::$driver->removeFolder($dir,$recursion); } public static function makeFolder($fullpath,$auth = 0755){ self::$hasInited or self::init(); return self::$driver->makeFolder($fullpath,$auth); } public static function readFolder($dir){ self::$hasInited or self::init(); return self::$driver->readFolder($dir); } }}namespace System\Core{ use System\Corax; use System\Exception\CoraxException; use System\Exception\ParameterInvalidException; use System\Util\SEK; use System\Core\Dao\Base; defined('BASE_PATH') or die('No Permission!'); class Dao{ const DB_TYPE_MYSQL = 'mysql'; const DB_TYPE_SQLSRV = 'sqlsrv'; const DB_TYPE_ORACLE = 'oci'; public $driver; protected $curStatement = null; protected $error = null; protected static $config = array( 'MASTER_NO' => 0, 'DB_CONNECT' => array( 0 => array( 'type' => Dao::DB_TYPE_MYSQL, 'dbname' => 'test', 'username' => 'root', 'password' => '123456', 'host' => 'localhost', 'port' => '3306', 'charset' => 'UTF8', 'dsn' => null, 'options' => array( \PDO::ATTR_ERRMODE => \PDO::ERRMODE_EXCEPTION, ), ), ), ); protected static $daoPool = array(); protected static $_hasInited = false; protected function __construct(array $config){ if(!isset($config['type'],$config['username'],$config['password'])){ throw new ParameterInvalidException($config); } isset($config['options']) or $config['options'] = self::$config['DB_CONNECT'][0]['options']; $classname = 'System\\Core\\DaoDriver\\'.ucwords($config['type']).'Driver'; $dsn = null; if(isset($config['dsn'])){ $dsn = $config['dsn']; }elseif(isset($config['host'])){ $dsn = self::buildDSN($config); } try{ $this->driver = new $classname($dsn,$config['username'],$config['password'],$config['options']); }catch (\PDOException $e){ Corax::handleException($e); } } public static function init($confnm='database'){ $config = Configer::load($confnm); if(isset($config)){ SEK::merge(static::$config,$config); } self::$_hasInited = true; } public static function getInstance($identifier=0,array $connect_config=null){ self::$_hasInited or self::init(); if(isset(self::$daoPool[$identifier])){ return self::$daoPool[$identifier]; } if(is_array($identifier)){ $connect_config = $identifier; }elseif(!isset($connect_config)){ $connect_config = self::$config['DB_CONNECT'][$identifier]; } return self::$daoPool[$identifier] = new Dao($connect_config); } public static function buildDSN($config){ $dsn = null; switch($config['type']){ case self::DB_TYPE_MYSQL: $dsn = "mysql:host={$config['host']}"; if(isset($config['dbname'])){ $dsn .= ";dbname={$config['dbname']}"; } if(!empty($config['port'])) { $dsn .= ';port=' . $config['port']; } if(!empty($config['socket'])){ $dsn .= ';unix_socket='.$config['socket']; } if(!empty($config['charset'])){ $dsn .= ';charset='.$config['charset']; } break; case self::DB_TYPE_SQLSRV: $dsn = 'sqlsrv:Server='.$config['hostname']; if(isset($config['dbname'])){ $dsn = ";Database={$config['dbname']}"; } if(!empty($config['hostport'])) { $dsn .= ','.$config['hostport']; } break; case self::DB_TYPE_ORACLE: $dsn = 'oci:dbname=//'.$config['hostname'].($config['port']?':'.$config['port']:'').'/'.$config['dbname']; if(!empty($config['charset'])) { $dsn .= ';charset='.$config['charset']; } break; default: throw new ParameterInvalidException($config); } return $dsn; } public static function getAvailableDrivers(){ return \PDO::getAvailableDrivers(); } public static function log($sql=false,array $bind=null){ static $_cache = array(); if(is_bool($sql)){ if($sql){ return $_cache; }else{ return end($_cache); } }elseif(is_array($sql)){ $_cache[] = $sql; }elseif(is_string($sql)){ $_cache[] = array($sql,$bind); }else{ throw new ParameterInvalidException($sql,$bind); } return true; } public function execute(array $input_parameters = null, \PDOStatement $statement=null){ isset($statement) and $this->curStatement = $statement; if(!$this->curStatement){ throw new CoraxException($this->curStatement,$input_parameters); } self::log(array($this->curStatement->queryString,$input_parameters)); if(!$this->curStatement->execute($input_parameters)){ $this->error = $this->getStatementErrorInfo(); return false; } return true; } public function query($sql){ self::log($sql); $rst = $this->driver->query($sql); if(false === $rst){ $this->error = $this->getPdoErrorInfo(); return false; } return $rst->fetchAll(); } public function exec($sql){ self::log($sql); try{ $rst = $this->driver->exec($sql); if(false === $rst){ $this->error = $this->getPdoErrorInfo(); return false; } return $rst; }catch (\PDOException $e){ $this->error = "exec sql of '{$sql}' failed!"; return false; } } public function prepare($sql,$option=array()){ $this->curStatement = $this->driver->prepare($sql,$option); return $this; } public function bindParam($parameter, &$variable, $data_type = \PDO::PARAM_STR, $length = null, $driver_options = null){ return $this->curStatement->bindParam($parameter,$variable,$data_type,$length,$driver_options); } public function bindValue($parameter, $value, $data_type = \PDO::PARAM_STR){ return $this->curStatement->bindValue($parameter, $value, $data_type); } public function bindColumn($column, &$param, $type = null, $maxlen = null, $driverdata = null){ return $this->curStatement->bindColumn($column,$param,$type,$maxlen,$driverdata); } public function getErrorInfo(){ return $this->error; } public function getPdoErrorInfo(){ $pdoError = $this->driver->errorInfo(); return isset($pdoError[1])?"Code:{$pdoError[0]} [{$pdoError[1]}]:[{$pdoError[2]}]":''; } public function getStatementErrorInfo(){ $stmtError = $this->curStatement->errorInfo(); return isset($stmtError[1])?"[{$stmtError[1]}]:[{$stmtError[2]}]":''; } public function beginTransaction(){ return $this->driver->beginTransaction(); } public function commit(){ return $this->driver->commit(); } public function rollBack(){ return $this->driver->rollBack(); } public function inTransaction(){ return $this->driver->inTransaction(); } public function closeCursor($statement=null){ isset($statement) and $this->curStatement = $statement; return $this->curStatement->closeCursor(); } public function columnCount(){ return $this->curStatement->columnCount(); } public function getStatementParams(){ ob_start(); $this->curStatement->debugDumpParams(); return ob_get_clean(); } public function fetch($fetch_style = null, $cursor_orientation = \PDO::FETCH_ORI_NEXT, $cursor_offset = 0){ isset($fetchStyle) or $fetch_style = $this->driver->getAttribute(\PDO::ATTR_DEFAULT_FETCH_MODE); return $this->curStatement->fetch($fetch_style,$cursor_orientation,$cursor_offset); } public function fetchAll($fetch_style = null, $fetch_argument = null, $constructor_args = null){ $param = array(); if(isset($fetch_style)){ $param[] = $fetch_style; if(isset($fetch_argument)){ $param[] = $fetch_argument; if(isset($constructor_args)){ $param[] = $constructor_args; } } } return call_user_func_array(array($this->curStatement,'fetchAll'),$param); } public function fetchColumn($column_number = 0){ return $this->curStatement->fetchColumn($column_number); } public function fetchObject($class_name = 'stdClass', array $constructor_args = array()){ return $this->curStatement->fetchObject($class_name,$constructor_args); } public function rowCount(){ return $this->curStatement->rowCount(); } public function doneExecute(){ $errorInfo = $this->getErrorInfo(); return empty($errorInfo)?$this->rowCount():$errorInfo; } public function doneQuery(){ $errorInfo = $this->getErrorInfo(); return empty($errorInfo)?$this:$errorInfo; } }}namespace System\Core{ use System\Util\SEK; defined('BASE_PATH') or die('No Permission!'); class Model{ protected $dao = null; protected $mapping = []; protected $fields = []; protected $prefix = ''; protected $primar_key = 'id'; protected $real_tablename = null; protected $model_name = null; protected $modules_name = null; public function __construct($config=null){ $matches = null; if(preg_match('/^Application\\\(.*)\\\Model\\\(.*)Model$/',get_called_class(),$matches)){ $this->modules_name = str_replace('\\','/',$matches[1]); $this->model_name = $matches[2]; }else{ throw new \Exception('Class "'.get_called_class().'" auto fetch falied!'); } if(isset($config)){ foreach($config as $name => $item){ $this->$name = $item; } }else{ if(!isset($this->real_tablename)){ $modelname = SEK::toJavaStyle($matches[2]); $this->setTableName($modelname); } } } protected function setTableName($tablename,$autofill_prefix=true){ if($autofill_prefix and $this->prefix and 0 !== strpos($tablename,$this->prefix)){ $this->real_tablename = $this->prefix.$tablename; }else{ $this->real_tablename = $tablename; } } protected function getTableName(){ return $this->real_tablename; } public function init($config='0'){ $this->dao = Dao::getInstance($config); } public function getErrorInfo(){ return isset($this->dao)? $this->dao->getErrorInfo() : ''; } public function query($sql,array $inputs=null){ isset($this->dao) or $this->init(); $rst = $this->dao->prepare($sql)->execute($inputs); if(false === $rst){ return false; } return $this->dao->fetchAll(); } public function execute($sql,array $inputs=null){ isset($this->dao) or $this->init(); $rst = $this->dao->prepare($sql)->execute($inputs); if(false === $rst){ return false; } return $this->dao->rowCount(); } public function create(array $fields,$tablename=null){ isset($this->dao) or $this->init(); isset($tablename) or $tablename = $this->getTableName(); return $this->dao->create($tablename,$fields); } public function update($fields=null,$where=null,$tablename=null){ isset($this->dao) or $this->init(); isset($tablename) or $tablename = $this->getTableName(); return $this->dao->update($tablename,$fields,$where); } public function select($fields=null,$where=null,$tablename=null){ isset($this->dao) or $this->init(); isset($tablename) or $tablename = $this->getTableName(); return $this->dao->select($tablename,$fields,$where); } public function find($fields=null,$where=null,$tablename=null){ isset($this->dao) or $this->init(); isset($tablename) or $tablename = $this->getTableName(); $rst = $this->dao->select($tablename,$fields,$where); return count($rst) !== 1? false:$rst[0]; } public function delete($where=null,$tablename=null){ isset($this->dao) or $this->init(); isset($tablename) or $tablename = $this->getTableName(); return $this->dao->delete($tablename,$where); } }}namespace System\Core{ use System\Corax; use System\Exception\FileNotFoundException; use System\Util\SEK; use System\Utils\LiteBuilder; class View{ protected $_config = array( 'left_delimiter' => '{', 'right_delimiter' => '}', ); protected $_tpl_dir = null; protected $_tpl_cache_dir = null; protected $_tpl_compile_dir = null; protected $_tpl_static_dir = null; protected static $_context = null; public static $tpl_engine = null; protected static $_smarty_lite_file = null; protected static $registed = false; protected $_tVars = array(); public function __construct($context){ self::$_context = $context; defined('SMARTY_DIR') or define('SMARTY_DIR',BASE_PATH.'System/Projects/Smarty/libs/'); if(!isset(self::$tpl_engine)){ require_once SMARTY_DIR.'Smarty.class.php'; static::$tpl_engine = new \Smarty(); static::$tpl_engine->left_delimiter = $this->_config['left_delimiter']; static::$tpl_engine->right_delimiter = $this->_config['right_delimiter']; null === self::$_smarty_lite_file and self::$_smarty_lite_file = RUNTIME_PATH.'Smarty.lite.php'; } self::$registed or $this->registerTemplateFunctions(); } private function registerTemplateFunctions(){ $this->registerPlugin('function','U',array($this,'U')); self::$registed = true; } public function U($params){ $url = $params['url']; unset($params['url']); if(isset($params['mode'])){ $mode = $params['mode']; unset($params['mode']); }else{ $mode = null; } return SEK::url($url,$params,$mode); } public function registerPlugin($type, $tag, $callback, $cacheable = true, $cache_attr = null){ return static::$tpl_engine->registerPlugin($type, $tag, $callback, $cacheable , $cache_attr); } public function setTemplateDir($path){ return static::$tpl_engine->setTemplateDir($path); } public function setCompileDir($path){ return static::$tpl_engine->setCompileDir($path); } public function setCacheDir($path){ return static::$tpl_engine->setCacheDir($path); } public function assign($tpl_var,$value=null,$nocache=false){ return self::$tpl_engine->assign($tpl_var,$value,$nocache); } public function display($template = null, $cache_id = null, $compile_id = null, $parent = null){ Corax::status('display_begin'); $context = &self::$_context; if($template){ $context = array_merge($context,self::parseTemplatePath($template)); } $suffix = '.'.TEMPLATE_EXT; if(false === strpos($context['a'],$suffix)){ $context['a'] .= $suffix; } $this->_tpl_cache_dir = RUNTIME_PATH."cache/{$context['m']}/{$context['c']}/"; $this->_tpl_dir = APP_PATH."{$context['m']}/View/{$context['c']}/"; if(isset($context['t']) and is_file($this->_tpl_dir."{$context['t']}/{$context['a']}")){ $this->_tpl_dir .= "{$context['t']}/"; } self::$tpl_engine->assign($this->_tVars); self::$tpl_engine->setTemplateDir($this->_tpl_dir); self::$tpl_engine->setCompileDir($this->_tpl_cache_dir.'compile/'); self::$tpl_engine->setCacheDir($this->_tpl_cache_dir.'static/'); Corax::status('display_gonna_to_begin'); self::$tpl_engine->display(self::$_context['a'],$cache_id,$compile_id,$parent); Corax::status('display_end'); } public static function parseTemplatePath($templatepath,$get_url=false){ $rst = array(); if($templatepath){ $tpos = strpos($templatepath,':'); $pathlen = strlen($templatepath); if(false !== $tpos){ $rst['t'] = substr($templatepath,$tpos+1,$pathlen-1); $templatepath = substr($templatepath,0,$tpos); } $mcpos = strpos($templatepath,'@'); if(false !== $mcpos){ $rst['m'] = substr($templatepath,0,$mcpos); $templatepath = substr($templatepath,$mcpos+1); } $capos = strpos($templatepath,'/'); if(false !== $capos){ $rst['c'] = substr($templatepath,0,$capos); $rst['a'] = substr($templatepath,$capos+1); }else{ $rst['a'] = $templatepath; } } if($get_url){ $url = APP_PATH; $context = &self::$_context; $url .= isset($rst['m']) ? "{$rst['m']}/":"{$context['m']}/"; $url .= isset($rst['c']) ? "View/{$rst['c']}/":"View/{$context['c']}/"; if(isset($rst['t'])){ $url .= "{$url}/{$rst['t']}/"; }elseif(isset($context['t'])){ $url .= "{$url}/{$context['t']}/"; } $url .= (isset($rst['a']) ? $rst['a']:$context['a']).'.'.TEMPLATE_EXT; return $url; } return $rst; } public function buildSmartyLite(){ defined('SMARTY_DIR') or define('SMARTY_DIR',BASE_PATH.'System/Projects/Smarty/libs/'); $files = array( SMARTY_DIR.'Smarty.class.php', ); LiteBuilder::build(self::$_smarty_lite_file,$files); } }}namespace System\Core{ use System\Corax; use System\Core\Router\DomainCreater; use System\Core\Router\DomainParser; use System\Core\Router\RuleCreater; use System\Core\Router\RuleParser; use System\Core\Router\URLCreater; use System\Core\Router\URLParser; use System\Exception\CoraxException; use System\Util\SEK; defined('BASE_PATH') or die('No Permission!'); class Router{ const URLMODE_COMMON = 1; const URLMODE_PATHINFO = 2; const URLMODE_COMPATIBLE = 3; const COMMONMODE_SOURCE_GET = 1; const COMMONMODE_SOURCE_POST = 2; const COMMONMODE_SOURCE_REQUEST = 3; const COMMONMODE_SOURCE_INPUT = 4; protected static $convention = [ 'DIRECT_ROUTE_ON' => false, 'INDIRECT_ROUTE_ON' => false, 'DIRECT_ROUTE_RULES' => [ 'DIRECT_STATIC_ROUTE_RULES' => [], 'DIRECT_WILDCARD_ROUTE_RULES' => [], 'DIRECT_REGULAR_ROUTE_RULES' => [], ], 'INDIRECT_ROUTE_RULES' => [], 'URL_CREATION_RULE' => [], 'URL_MODULE_VARIABLE' => '_m', 'URL_CONTROLLER_VARIABLE' => '_c', 'URL_ACTION_VARIABLE' => '_a', 'URL_COMPATIBLE_VARIABLE' => '_pathinfo', 'COMMONMODE_SOURCE' => self::COMMONMODE_SOURCE_GET, 'MM_BRIDGE' => '/', 'MC_BRIDGE' => '/', 'CA_BRIDGE' => '/', 'AP_BRIDGE' => '/co/', 'PP_BRIDGE' => '/', 'PKV_BRIDGE' => '/', 'MASQUERADE_TAIL' => '.html', 'REWRITE_HIDDEN' => '/index.php', 'DEFAULT_MODULE' => 'Home', 'DEFAULT_CONTROLLER' => 'Index', 'DEFAULT_ACTION' => 'index', 'DOMAIN_DEPLOY_ON' => false, 'DOMAIN_MODULE_BIND' => true, 'FUL_DOMAIN'=>'', 'HOST_PROTOCOL' => 'http', 'HOST_PORT' => 80, 'SUB_DOMAIN_MODULE_MAPPING_ON' => true, 'SUB_DOMAIN_DEPLOY_RULES' => [ ], ]; private static $parsedResult = []; protected static $hasInitialized = false; protected static $moduleDomainBinded = false; protected function __construct(){} final public static function init(array $config=null){ Corax::status('router_init_begin'); SEK::merge(self::$convention, isset($config) ? $config : Configer::load('route'),true); self::$parsedResult['m'] = self::$convention['DEFAULT_MODULE']; self::$parsedResult['c'] = self::$convention['DEFAULT_CONTROLLER']; self::$parsedResult['a'] = self::$convention['DEFAULT_ACTION']; self::$parsedResult['p'] = []; self::$moduleDomainBinded = false; self::$hasInitialized = true; Corax::status('router_init_done'); } final public static function getParsed($part=null){ self::$hasInitialized or self::init(); if(isset($part)){ return isset(self::$parsedResult[$part])?self::$parsedResult[$part]:null; }else{ return self::$parsedResult; } } final public static function analyse($hostname=null,$url=null,$forceRefresh=false){ self::$hasInitialized or self::init(); if(URLMODE_TOPSPEED_ON){ $parsed = URLParser::parse(null,self::URLMODE_COMMON); self::pushParsed($parsed); }else{ if(self::$convention['DOMAIN_DEPLOY_ON']){ $result = DomainParser::getInstance(self::$convention,$forceRefresh)->parse($hostname); if(is_array($result)){ self::pushParsed($result); self::$moduleDomainBinded = (isset($result['m']) and self::$convention['DOMAIN_MODULE_BIND']); } } $ruleParser = RuleParser::getInstance(self::$convention,$forceRefresh); if(self::$convention['DIRECT_ROUTE_ON']){ isset($url) or $url = self::getPathInfo(); $result = $ruleParser->parseDirectRules($url); if(null !== $result){ if(is_string($result)){ $url = $result; }elseif(is_array($result)){ return self::pushParsed($result); }else{ throw new CoraxException($result); } } } $parsed = URLParser::parse($url); self::pushParsed($parsed); if(self::$convention['INDIRECT_ROUTE_ON']){ $result = $ruleParser->parseIndirectRules( self::$parsedResult['m'],self::$parsedResult['c'], self::$parsedResult['a'],self::$parsedResult['p']); if(null !== $result){ return self::pushParsed($result); } } } return self::$parsedResult; } final public static function build($modulelist=null,$controller=null,$action=null,$params=[],$mode=null){ self::$hasInitialized or self::init(); $url = null; $moduleback = null; isset($modulelist) or $modulelist = self::$parsedResult['m']; isset($controller) or $controller = self::$parsedResult['c']; isset($action) or $action = self::$parsedResult['a']; if(URLMODE_TOPSPEED_ON){ $url = URLCreater::create($modulelist,$controller,$action,$params,self::URLMODE_COMMON); }else{ $port = (self::$convention['HOST_PORT'] === 80)?'':':'.self::$convention['HOST_PORT']; if(self::$convention['DOMAIN_DEPLOY_ON']){ $hostname = DomainCreater::getInstance(self::$convention)->create($modulelist); if(isset($hostname)){ $moduleback = $modulelist; $modulelist = null; $url = $hostname.$port; } } $protocal = self::$convention['HOST_PROTOCOL']; $url .= isset($url)?"{$protocal}:/{$url}{$port}":"{$protocal}://{$_SERVER['SERVER_NAME']}{$port}"; if(self::$convention['DIRECT_ROUTE_ON']) { RuleCreater::getInstance(self::$convention)->create($moduleback,$controller,$action,$params,$modulelist); } if(URLMODE_TOPSPEED_ON){ $url .= URLCreater::create($modulelist,$controller,$action,$params,self::URLMODE_COMMON); }else{ $mode = (null === $mode)?URL_MODE:intval($mode); $url .= URLCreater::create($modulelist,$controller,$action,$params,$mode); } } return $url; } private static function pushParsed(array &$result) { if(!self::$moduleDomainBinded) { isset($result['m']) and self::$parsedResult['m'] = $result['m']; } isset($result['c']) and self::$parsedResult['c'] = $result['c']; isset($result['a']) and self::$parsedResult['a'] = $result['a']; isset($result['p']) and SEK::merge(self::$parsedResult['p'],$result['p']); $_GET = array_merge(self::$parsedResult['p'],$_GET); return self::$parsedResult; } protected static function buildKey($modules=null,$ctler=null,$action=null,$params=null) { $key = ''; if($modules) $key .= self::toModulesString($modules).'/'; if($ctler and is_string($ctler)) $key .= "{$ctler}/"; if($action and is_string($action)) $key .= "{$action}/"; if($params){ if(is_array($params)){ $temp = ''; foreach($params as $pname=>$pval){ $temp .= "{$pname}/{$pval}/"; } $key .= trim($temp,'/'); }else{ throw new CoraxException($params); } } return strtolower($key); } protected static function stripMasqueradeTail($uri){ if(is_string($uri)){ $uri = trim($uri); $position = stripos($uri,self::$convention['MASQUERADE_TAIL']); if(false !== $position and strlen($uri) === ($position + strlen(self::$convention['MASQUERADE_TAIL'])) ){ $uri = substr($uri,0,$position); } }elseif(is_array($uri)){ foreach($uri as $key=> &$val){ $val = self::stripMasqueradeTail($val); } }else{ throw new CoraxException($uri); } return $uri; } protected static function getPathInfo(){ static $pathinfo = null; if(null === $pathinfo){ if(isset($_SERVER['PATH_INFO'])) { $pathinfo = $_SERVER['PATH_INFO']; }else{ if(strlen($_SERVER['REQUEST_URI']) > strlen($_SERVER['SCRIPT_NAME'])){ $pos = stripos($_SERVER['REQUEST_URI'],$_SERVER['SCRIPT_NAME']); if(0 === $pos){ $pathinfo = substr($_SERVER['REQUEST_URI'], strlen($_SERVER['SCRIPT_NAME'])); }else{ $pathinfo = $_SERVER['REQUEST_URI']; } } } } return $pathinfo; } protected static function toModulesArray($modules,$delimiter=null){ isset($delimiter) or $delimiter = self::$convention['MM_BRIDGE']; if(is_string($modules)){ $modules = explode($delimiter,$modules); } if(!is_array($modules)){ throw new CoraxException('Parameter should be an array!'); } return array_map(function ($val) { return SEK::toJavaStyle($val); }, $modules); } protected static function toParametersArray($params,$ppb,$pkvb){ $pc = []; if($ppb !== $pkvb){ $parampairs = explode($ppb,$params); foreach($parampairs as $val){ $pos = strpos($val,$pkvb); if(false === $pos){ }else{ $key = substr($val,0,$pos); $val = substr($val,$pos+strlen($pkvb)); $pc[$key] = $val; } } }else{ $elements = explode($ppb,$params); $count = count($elements); for($i=0; $i<$count; $i += 2){ if(isset($elements[$i+1])){ $pc[$elements[$i]] = $elements[$i+1]; }else{ } } } return $pc; } protected static function toModulesString($modules){ if(is_array($modules)){ foreach($modules as &$modulename){ $modulename = SEK::toCStyle($modulename); } $modules = implode(self::$convention['MM_BRIDGE'],$modules); } if(!is_string($modules)) throw new CoraxException('Invalid Parameters'); return trim($modules); } protected static function toParametersString(array $params,$ppb,$pkvb){ $temp = ''; if($params){ foreach($params as $key => $val){ $temp .= "{$key}{$pkvb}{$val}{$ppb}"; } return substr($temp,0,strlen($temp) - strlen($ppb)); }else{ return $temp; } } }}namespace System\Core\Cache{ use System\Util\SEK; class File implements CacheInterface { private $convention = [ 'DATA_CACHE_PATH' => RUNTIME_PATH.'Cache/', 'DATA_CACHE_PREFIX' => '', 'DATA_CACHE_TIME' => 0, 'DATA_CACHE_LENGTH' => 0, 'DATA_CACHE_TEMP_AUTH' => 0755, 'DATA_CACHE_KEY' => '', 'DATA_CACHE_COMPRESS' => false, 'DATA_CACHE_CHECK' => false, 'DATA_CACHE_TYPE' => 'File', 'DATA_CACHE_SUBDIR' => false, 'DATA_PATH_LEVEL' => 1, ]; private $options = []; public function __construct(array $config=null) { isset($config) and SEK::merge($this->convention,$config['FILE_CONF']); $this->options['temp'] = $this->convention['DATA_CACHE_PATH']; $this->options['prefix'] = $this->convention['DATA_CACHE_PREFIX']; $this->options['expire'] = $this->convention['DATA_CACHE_TIME']; $this->options['length'] = $this->convention['DATA_CACHE_LENGTH']; if(!is_dir($this->options['temp'])){ mkdir($this->options['temp'],$this->convention['DATA_CACHE_TEMP_AUTH'],true); }else{ chmod($this->options['temp'],$this->convention['DATA_CACHE_TEMP_AUTH']); } } private function filename($name) { $name = md5($this->convention['DATA_CACHE_KEY'].$name); if($this->convention['DATA_CACHE_SUBDIR']) { $dir =''; for($i=0;$i<$this->convention['DATA_PATH_LEVEL'];$i++) { $dir .= $name{$i}.'/'; } if(!is_dir($this->options['temp'].$dir)) { mkdir($this->options['temp'].$dir,0755,true); } $filename = $dir.$this->options['prefix'].$name.'.php'; }else{ $filename = $this->options['prefix'].$name.'.php'; } return $this->options['temp'].$filename; } public function get($name) { $filename = $this->filename($name); if (!is_file($filename)) { return false; } $content = file_get_contents($filename); if( false !== $content) { $expire = (int)substr($content,8, 12); if($expire != 0 && time() > filemtime($filename) + $expire) { unlink($filename); return false; } if($this->convention['DATA_CACHE_CHECK']) { $check = substr($content,20, 32); $content = substr($content,52, -3); if($check != md5($content)) { return false; } }else { $content = substr($content,20, -3); } if($this->convention['DATA_CACHE_COMPRESS'] && function_exists('gzcompress')) { $content = gzuncompress($content); } $content = unserialize($content); return $content; } else { return false; } } private function mb_unserialize($serial_str) { $out = preg_replace_callback ('!s:(\d+):"(.*?)";!se', function($matches){ return "'s:'.strlen('{$matches[2]}').':\"{$matches[2]}\";'"; }, $serial_str ); return unserialize($out); } public function set($name,$value,$expire=null) { if(is_null($expire)) { $expire = $this->options['expire']; } $filename = $this->filename($name); $data = serialize($value); if( $this->convention['DATA_CACHE_COMPRESS'] && function_exists('gzcompress')) { $data = gzcompress($data,3); } if( $this->convention['DATA_CACHE_CHECK']) { $check = md5($data); }else { $check = ''; } $data = "<?php\n//".sprintf('%012d',$expire).$check.$data."\n?>"; $result = file_put_contents($filename,$data); if($result) { if($this->options['length']>0) { $this->queue($name); } clearstatcache(); return true; }else { return false; } } protected function queue($key) { static $_handler = array( 'file' => array('F','F'), 'xcache'=> array('xcache_get','xcache_set'), 'apc' => array('apc_fetch','apc_store'), ); $queue = isset($this->options['queue'])?$this->options['queue']:'file'; $fun = isset($_handler[$queue])?$_handler[$queue]:$_handler['file']; $queue_name = isset($this->options['queue_name'])?$this->options['queue_name']:'think_queue'; $value = $fun[0]($queue_name); if(!$value) { $value = array(); } if(false===array_search($key, $value)) array_push($value,$key); if(count($value) > $this->options['length']) { $key = array_shift($value); $this->rm($key); } return $fun[1]($queue_name,$value); } public function rm($name) { return unlink($this->filename($name)); } public function clear() { $path = $this->options['temp']; $files = scandir($path); if($files){ foreach($files as $file){ if ($file != '.' && $file != '..' && is_dir($path.$file) ){ array_map( 'unlink', glob( $path.$file.'/*.*' ) ); }elseif(is_file($path.$file)){ unlink( $path . $file ); } } return true; } return false; } }}